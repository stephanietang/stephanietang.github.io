<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"stephanietang.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Stephanie Tang&#39;s Blog">
<meta property="og:url" content="http://stephanietang.github.io/index.html">
<meta property="og:site_name" content="Stephanie Tang&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Stephanie Tang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://stephanietang.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Stephanie Tang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Stephanie Tang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2018/06/25/SSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/25/SSL/" class="post-title-link" itemprop="url">SSL的工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-25 23:49:43" itemprop="dateCreated datePublished" datetime="2018-06-25T23:49:43+08:00">2018-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-06-26 09:57:10" itemprop="dateModified" datetime="2018-06-26T09:57:10+08:00">2018-06-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SSL-TLS是什么"><a href="#SSL-TLS是什么" class="headerlink" title="SSL/TLS是什么"></a>SSL/TLS是什么</h3><p>目前互联网常用的HTTP协议是非常不安全的明文传输协议。而SSL协议及其继任者TLS协议，是一种实现网络通信加密的安全协议，可在客户端（浏览器）和服务器端（网站）之间建立一条加密通道，保证数据在传输过程中不被窃取或篡改。</p>
<p>SSL证书，也称为服务器SSL证书，是遵守SSL协议的一种数字证书，由全球信任的证书颁发机构(Certificate Authority,简称CA)验证服务器身份后颁发。将SSL证书安装在网站服务器上，可实现网站身份验证和数据加密传输双重功能。</p>
<p>首先搞清楚什么是SSL，什么是TLS。</p>
<ol>
<li>HTTP协议是明文传输协议，是非常不安全的，很容易被人篡改和窃取数据。</li>
<li>SSL(Secure Socket Layer) - netscape公司设计的主要用于web的安全传输协议。这种协议在web上获得了广泛的应用。</li>
<li>TLS(Transport Layer Security)- IETF(<a href="http://www.ietf.org)将SSL作了标准化，从技术上讲，TLS1.0与SSL3.0的差别非常小。" target="_blank" rel="noopener">www.ietf.org)将SSL作了标准化，从技术上讲，TLS1.0与SSL3.0的差别非常小。</a></li>
</ol>
<blockquote>
<p>由于本文讨论不涉及阐述SSL和TLS的微小差异，所以将二者视为等价。</p>
</blockquote>
<h3 id="SSL的工作原理"><a href="#SSL的工作原理" class="headerlink" title="SSL的工作原理"></a>SSL的工作原理</h3><h3 id="keystore和truststore"><a href="#keystore和truststore" class="headerlink" title="keystore和truststore"></a>keystore和truststore</h3><p>keytool是java自带的工具用于产生密钥</p>
<p>keystore可以看成一个放key的库，key就是公钥，私钥，数字签名等组成的一个信息。</p>
<p>truststore是放信任的证书的一个store.</p>
<p>这篇主要针对的是web应用，web应用一般是通过https,ssl来做客户端和server端的链接 </p>
<p>就以单向验证为例，服务器端的app server是tomcat</p>
<p>目前比较常用（我感觉是简单）的安全方案是单向验证，也就是说，客户端IE会验证服务器端的身份。这需要在服务器端做一些配置。</p>
<ol>
<li><p>在命令行中通过使用keytool在keystore中生成一个key.</p>
<p>这里就有两个概念了，keystore和key</p>
<p>key,存放了数字证书（包括公钥和发布者的数字签名）,以及私钥</p>
<p>keystore,可以认为是放key的一个仓库，以文件的形式存在系统中，默认是放在C:\Documents and Settings\user…\下，也可以在命令行中指定路径和文件名</p>
</li>
</ol>
<p>2.将key以数字证书的形式从keystore中导出，数字证书（包括公钥和发布者的数字签名）</p>
<p>3.将数字证书导入到truststore,一般是tomcat所用的JAVA_HOME下的jre\lib\security\cacerts文件</p>
<p>  其实，truststore和keystore的性质是一样的，都是存放key的一个仓库，区别在于，truststore里存放的是只包含公钥的数字证书，代表了可以信任的证书，而keystore是包含私钥的。</p>
<p>4.配置tomcat下的server.xml里相应的ssl端口，这样客户端就可以通过https来访问server了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2018/03/01/Singleton-DesignPattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/01/Singleton-DesignPattern/" class="post-title-link" itemprop="url">单例设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-01 09:22:52" itemprop="dateCreated datePublished" datetime="2018-03-01T09:22:52+08:00">2018-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-06-25 23:32:40" itemprop="dateModified" datetime="2018-06-25T23:32:40+08:00">2018-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>单例设计模式(Singleton Design Pattern)指的是实现一个类，在应用中只有唯一一个实例。但现在已经成为业界共识，它成为了反模式的代表。这篇文章先讨论实现单例模式的几种方式，然后讨论为什么它是一种反模式。以及它的应用场景。</p>
<p>我们先来讨论单例模式的几种实现方法。</p>
<h3 id="饿汉式-Eager-Initialization）"><a href="#饿汉式-Eager-Initialization）" class="headerlink" title="饿汉式(Eager Initialization）"></a>饿汉式(Eager Initialization）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitializationSingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerInitializationSingleton instance = <span class="keyword">new</span> EagerInitializationSingleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//private constructor to avoid client applications to use constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerInitializationSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerInitializationSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种写法不算很复杂，因为声明了static和final，在类加载的时候就实例化了，另外将constructor声明为private，也就是不能使用new来创建实例，而只能使用<code>getInstance()</code>来得到唯一的实例，从而保证了只有一个实例。</p>
<p>但是这种方法的坏处显而易见，它在类加载的时候就初始化了，对于从来没有用过但是创建又需要很多资源的对象，这无疑是一种浪费。于是就有了懒汉式(lazy initialization)。</p>
<h3 id="双检锁-Double-Checked-Locking"><a href="#双检锁-Double-Checked-Locking" class="headerlink" title="双检锁(Double Checked Locking)"></a>双检锁(Double Checked Locking)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Double-checked Locking Lazy Initialization</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLockSingleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckedLockSingleton singleton;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckedLockSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(DoubleCheckedLockSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">					singleton = <span class="keyword">new</span> DoubleCheckedLockSingleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种双检锁是一种懒汉式——只有调用<code>getInstance()</code>的时候才实例化对象。但逻辑比饿汉式复杂许多，让我们来仔细看一看。<br><code>getInstance()</code>方法中使用了双检锁，这么做避免了同步整个getInstance()方法，因为只是在第一次实例化时需要同步，创建好之后，就可以直接返回已经创建好的singleton了。又是懒汉式，又不需要同步整个getInstance()方法影响性能，开销不算太大。<br>然而这里还有个坑，注意这里的<code>volatile</code>，尽管有了<code>synchronized</code>，但如果没有声明<code>volatile</code>，这个看似完美的方法还是会失效。<br>话说因为<code>singleton = new DoubleCheckedLockSingleton()</code>这个操作实际上含有三个步骤</p>
<p>(1) 给singleton对象分配内存<br>(2) 调用构造器来初始化成员变量<br>(3) 将singleton对象指向分配好的内存空间(执行这一步之后singleton != null)</p>
<p>然而JMM中指令是存在重排序的，也就是不能保证(2)和(3)的次序。<br>假设两个线程同时进入第一层<code>if(singleton == null)</code>，假设线程A首先进入了<code>synchronized block</code>，但是执行完<code>singleton = new DoubleCheckedLockSingleton()</code>之后，仅仅只完成了步骤(3)，singleton对象指向分配好的内存空间（并没有完成构造器的初始化工作），然后返回。线程B这时候进入<code>synchronized block</code>，看见singleton已经不等于null了，于是也返回了，然后使用这个没有真正初始化完成的实例，便会有不可预知的问题。<br>所以这里加上<code>volatile</code>之后禁止指令重排，根据happens-before原则，写操作将会先行发生于后面发生的读操作，也就是线程B一定读到的是线程A实例化完整的实例。<br>但是请注意，即使是使用了<code>volatile</code>，在Java 5之前仍旧是有问题的，Java 5之前的JMM<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">有bug</a>，并不能保证禁止重排序。<br>所以对于这么多坑的一种写法，我们明白了原理就算了，能避免就避免吧。</p>
<h3 id="静态内部类-Static-Inner-Class"><a href="#静态内部类-Static-Inner-Class" class="headerlink" title="静态内部类(Static Inner Class)"></a>静态内部类(Static Inner Class)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingleton INSTANCE = <span class="keyword">new</span> InnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法也是懒汉式的，同时读取实例的时候不会进行同步，没有性能缺陷，也不依赖JDK版本。完美！</p>
<h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法太简单了！有没有！它也是懒汉式的，天然的保证了线程安全，天然的不需要同步，不过当然需要Java 5以上的版本啦（Java 5之前也得有enum才行啊！），也是《Effective Java》上推荐的方法。</p>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>这里有一篇关于几种写法的性能比较：<a href="http://literatejava.com/jvm/fastest-threadsafe-singleton-jvm/" target="_blank" rel="noopener">Fastest Thread-safe Singleton in Java</a></p>
<p>但是没有出乎意料，对于懒汉式的写法中，静态内部类 &gt; 双检锁 &gt; synchronized getInstance方法（本文没有讨论，因为性能实在是堪忧）。这里没有比较enum，留给有兴趣的童鞋吧。</p>
<p>如果一定要实现一个单例设计模式，就我而言，我会采用enum的写法。</p>
<h2 id="为什么单例模式是一个反模式？"><a href="#为什么单例模式是一个反模式？" class="headerlink" title="为什么单例模式是一个反模式？"></a>为什么单例模式是一个反模式？</h2><p>那么讨论完单例模式的几种实现方法，我们再来说明为什么它已然已经成为业界共识的反模式了。纳尼？前面铺垫那么多，不是白讨论了吗？！虽然是浪费了很多口舌，但是单例模式依然有他的应用场景，我们后面会说。</p>
<p>首先我们要搞清楚两个概念：单例模式和单例。前者是一种设计模式，它的特征是：1)私有的构造器，2)通过<code>Singleton.getInstance()</code>方法获得该类的唯一实例。而单例指的是一个类有且只有一个实例，可以通过依赖注入来实现。Spring中，我们常用的service或者dao通常就是典型的单例，它们通过BeanFactory来进行依赖注入，来保证应用中引用的都是一个类的同一个实例。</p>
<p>要注意的是，Spring中默认的singleton scope和严格意义上单例还是有区别的，来自Spring的文档中指出：</p>
<blockquote>
<p>When a bean is a singleton, only one shared instance of the bean will be managed and all requests for beans with an id or ids matching that bean definition will result in that one specific bean instance being returned.</p>
</blockquote>
<p>也就是说你在Spring中定义了singleton的使用范围，并不能保证你的bean在应用中是绝对的唯一实例，因为这个bean通常有公有的构造器，你完全可以绕过Spring而<code>new</code>一个实例。</p>
<p>单例模式之所以是一个反模式，是因为：</p>
<ul>
<li>它通常是一个复杂的object，维护着一个全局的状态，而全局的状态使得结果不可预测</li>
<li>由于是私有构造器，单元测试变得困难</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>基本的原则就是<strong>不要自己实现单例模式</strong>，然而依然有场景（为数不多的）适合使用单例模式，譬如logging：</p>
<ul>
<li>客户代码需要一个全局的logging service来发送请求去写log</li>
<li>多个监听器(listener)可以注册同一个logging service</li>
<li>虽然不同的应用会有不同的输出，它们注册监听器的方法是一样的，它们可以定制监听器来实现不同的配置，客户代码不需要知道log在哪里或如何写log的</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确地写出单例模式</a></li>
<li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">The “Double-Checked Locking is Broken” Declaration</a></li>
<li><a href="http://literatejava.com/jvm/fastest-threadsafe-singleton-jvm/" target="_blank" rel="noopener">Fastest Thread-safe Singleton in Java</a></li>
<li><a href="http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/" target="_blank" rel="noopener">Singletons are Pathological Liars</a></li>
<li><a href="http://misko.hevery.com/2008/08/21/where-have-all-the-singletons-gone/" target="_blank" rel="noopener">Where Have All the Singletons Gone?</a></li>
<li><a href="http://misko.hevery.com/2008/08/25/root-cause-of-singletons/" target="_blank" rel="noopener">Root Cause of Singletons</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2017/12/02/ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/02/ThreadLocal/" class="post-title-link" itemprop="url">深入理解Java中的ThreadLocal</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-02 09:22:52" itemprop="dateCreated datePublished" datetime="2017-12-02T09:22:52+08:00">2017-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-03-17 14:36:36" itemprop="dateModified" datetime="2018-03-17T14:36:36+08:00">2018-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h2><ol>
<li><p>每个<code>Thread</code>中都维护有一个<code>ThreadLocalMap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个<code>ThreadLocalMap</code>的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>就是每个线程要独立使用的Object。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">...    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个<code>Thread</code>要获得Object的时候，首先会调用<code>getMap(Thread t)</code>找到当前线程的<code>ThreadLocalMap</code>，然后使用<code>ThreadLocal</code>实例作为<code>key</code>，找到对应的<code>value</code>，也就是要找的Object。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这样每个线程都有独立使用的Object，就不会有线程之间相互干扰的问题，也不需要同步，因为不存在线程共享。</p>
</li>
</ol>
<h2 id="ThreadLocal的内存泄漏问题"><a href="#ThreadLocal的内存泄漏问题" class="headerlink" title="ThreadLocal的内存泄漏问题"></a>ThreadLocal的内存泄漏问题</h2><p>从源代码中，我们可以知道<code>ThreadLocalMap.Enty</code>对key（也就是<code>ThreadLocal</code>实例）是<code>WeakReference</code>，那么GC会将ThreadLocal回收，然而Entry的value不会被回收。但是如果线程及时结束，因为<code>ThreadLocalMap</code>和<code>Thread</code>的生命周期是一样的，所以ThreadLocalMap也会被回收，也就不会有内存泄漏的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题就出在假如使用了线程池，线程池中的线程完成任务后还会继续放回线程池而不会结束，这样就造成了泄漏：value中的Object虽然不会再被访问到(因为作为key的ThreadLocal已经被回收了)，但是由于ThreadLocalMap.Entry对value还存在强引用，所以value不会被回收，而Thread又一直存活，这样value就永远无法被回收了。</p>
<h2 id="解决ThreadLocal内存泄漏的最佳实践"><a href="#解决ThreadLocal内存泄漏的最佳实践" class="headerlink" title="解决ThreadLocal内存泄漏的最佳实践"></a>解决ThreadLocal内存泄漏的最佳实践</h2><p>解决方案一：不在有线程池的web应用中使用ThreadLocal</p>
<p>解决方案二：如果一定要在有线程池的web应用中使用ThreadLocal，那么在线程执行完任务之前，要调用<code>ThreadLocal.remove()</code>来清除value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(value);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a></li>
<li><a href="http://niklasschlimm.blogspot.hk/2012/04/threading-stories-threadlocal-in-web.html" target="_blank" rel="noopener">Threading stories: ThreadLocal in web applications</a></li>
<li><a href="https://github.com/dropwizard/metrics/issues/742" target="_blank" rel="noopener">https://github.com/dropwizard/metrics/issues/742</a></li>
<li><a href="https://wiki.apache.org/tomcat/MemoryLeakProtection" target="_blank" rel="noopener">https://wiki.apache.org/tomcat/MemoryLeakProtection</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2017/12/01/why-SimpleDateFormat-is-not-thread-safe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/01/why-SimpleDateFormat-is-not-thread-safe/" class="post-title-link" itemprop="url">为什么SimpleDateFormat不是线程安全的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-01 11:12:05" itemprop="dateCreated datePublished" datetime="2017-12-01T11:12:05+08:00">2017-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-12-02 09:56:06" itemprop="dateModified" datetime="2017-12-02T09:56:06+08:00">2017-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么SimpleDateFormat不是线程安全的"><a href="#为什么SimpleDateFormat不是线程安全的" class="headerlink" title="为什么SimpleDateFormat不是线程安全的"></a>为什么SimpleDateFormat不是线程安全的</h2><p>我们用一个简单的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatNotThreadSafe</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateFormat FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> MyThread(String.valueOf(i));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        MyThread(String threadName) &#123;</span><br><span class="line">            <span class="keyword">super</span>(threadName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Created Thread "</span> + getName() + <span class="string">", "</span>+ FORMAT.parse(<span class="string">"2016-01-01"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span>( Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于是多线程程序，线程运行的先后不可预知。但是奇怪的事情发生了，连可预知的<code>FORMAT.parse(&quot;2016-01-01&quot;)</code>也出现了奇怪的结果。</p>
<p>以下是几个可能出现的错误结果：</p>
<p>错误结果1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Created Thread 2, Wed Jan 01 00:00:00 HKT 2200</span><br><span class="line">Created Thread 6, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 7, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 8, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 4, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 3, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 9, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 0, Wed Jan 01 00:00:00 HKT 2200</span><br><span class="line">Created Thread 1, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 5, Fri Jan 01 00:00:00 HKT 2016</span><br></pre></td></tr></table></figure>

<p>错误结果2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Created Thread 1, Sat May 26 09:34:08 HKT 164390675</span><br><span class="line">Created Thread 3, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 4, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 0, Fri Jan 01 00:00:00 HKT 42016</span><br><span class="line">Created Thread 5, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 6, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 2, Fri Jan 01 00:00:00 HKT 42016</span><br><span class="line">Created Thread 7, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1110)</span><br><span class="line">    at java.lang.Double.parseDouble(Double.java:540)</span><br><span class="line">    at java.text.DigitList.getDouble(DigitList.java:168)</span><br><span class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1321)</span><br><span class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2088)</span><br><span class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)</span><br><span class="line">    at java.text.DateFormat.parse(DateFormat.java:355)</span><br><span class="line">    at com.examples.tutorials.SimpleDateFormatNotThreadSafe$MyThread.run(SimpleDateFormatNotThreadSafe.java:27)</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1110)</span><br><span class="line">    at java.lang.Double.parseDouble(Double.java:540)</span><br><span class="line">    at java.text.DigitList.getDouble(DigitList.java:168)</span><br><span class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1321)</span><br><span class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)</span><br><span class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)</span><br><span class="line">    at java.text.DateFormat.parse(DateFormat.java:355)</span><br><span class="line">    at com.examples.tutorials.SimpleDateFormatNotThreadSafe$MyThread.run(SimpleDateFormatNotThreadSafe.java:27)</span><br></pre></td></tr></table></figure>

<p>错误结果3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: For input string: &quot;.11E.111E&quot;</span><br><span class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1250)</span><br><span class="line">    at java.lang.Double.parseDouble(Double.java:540)</span><br><span class="line">    at java.text.DigitList.getDouble(DigitList.java:168)</span><br><span class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1321)</span><br><span class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)</span><br><span class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)</span><br><span class="line">    at java.text.DateFormat.parse(DateFormat.java:355)</span><br><span class="line">    at com.examples.tutorials.SimpleDateFormatNotThreadSafe$MyThread.run(SimpleDateFormatNotThreadSafe.java:27)</span><br><span class="line">java.lang.NumberFormatException: For input string: &quot;.11E.111E1&quot;</span><br><span class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1250)</span><br><span class="line">    at java.lang.Double.parseDouble(Double.java:540)</span><br><span class="line">    at java.text.DigitList.getDouble(DigitList.java:168)</span><br><span class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1321)</span><br><span class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)</span><br><span class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)</span><br><span class="line">    at java.text.DateFormat.parse(DateFormat.java:355)</span><br><span class="line">    at com.examples.tutorials.SimpleDateFormatNotThreadSafe$MyThread.run(SimpleDateFormatNotThreadSafe.java:27)</span><br><span class="line">Created Thread 1, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 6, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 3, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 5, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 4, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 7, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 8, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 9, Fri Jan 01 00:00:00 HKT 2016</span><br></pre></td></tr></table></figure>

<p>这正是因为SimpleDateFormat是非线程安全所导致的，这应该是设计者的错误。但是基于向后兼容，JDK中一直没有将它改为线程安全。然后Java 8引入了新的类解决了这一问题，下面会进行详细阐述。<br>从SimpleteDateFormat的<a href="http://developer.classpath.org/doc/java/text/SimpleDateFormat-source.html" target="_blank" rel="noopener">源代码</a>中可以知道，<code>parse(..)</code>的时候，首先会<code>calender.clear()</code>，然后会<code>calender.set(..)</code>。如果一个线程<code>parse(..)</code>还没有返回，另一个线程也进入了<code>parse(..)</code>并进行了<code>calender.clear()</code>，那么第一个线程将会得到意想不到的结果。</p>
<p>所以在SimpleDateFormat的文档中，也做了说明：</p>
<blockquote>
<p>Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p>
</blockquote>
<h2 id="如何写出线程安全的date-formatter"><a href="#如何写出线程安全的date-formatter" class="headerlink" title="如何写出线程安全的date formatter"></a>如何写出线程安全的date formatter</h2><p>针对写出线程安全的date formatter，在Java 8之前主要有三种方法:</p>
<ul>
<li>每个线程使用单独的DateFormat实例</li>
<li>使用synchronized进行同步</li>
<li>使用ThreadLocal</li>
</ul>
<h3 id="每个线程使用单独的DateFormat实例"><a href="#每个线程使用单独的DateFormat实例" class="headerlink" title="每个线程使用单独的DateFormat实例"></a>每个线程使用单独的DateFormat实例</h3><p>在每个线程里，创建一个新的DateFormat实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatThreadSafe</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convertStringToDate</span><span class="params">(String dateString)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        <span class="keyword">return</span> df.parse(dateString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法虽然实现起来很简单，但是效率非常的低。</p>
<h3 id="使用synchronized进行同步"><a href="#使用synchronized进行同步" class="headerlink" title="使用synchronized进行同步"></a>使用synchronized进行同步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatThreadSafeSynchronized</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateFormat FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convertStringToDate</span><span class="params">(String dateString)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        Date result;</span><br><span class="line">        <span class="keyword">synchronized</span>(FORMAT) &#123;</span><br><span class="line">            result = FORMAT.parse(dateString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalThreadSafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; FORMAT = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convertStringToDate</span><span class="params">(String dateString)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FORMAT.get().parse(dateString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以上三种方法的性能测试"><a href="#以上三种方法的性能测试" class="headerlink" title="以上三种方法的性能测试"></a>以上三种方法的性能测试</h3><p><a href="https://www.javacodegeeks.com/2010/07/java-best-practices-dateformat-in.html" target="_blank" rel="noopener">有人</a>针对以上的三种方法进行了性能测试，性能排序为：</p>
<p>使用ThreadLocal &gt; 使用synchronized进行同步 &gt; 每个线程使用单独的DateFormat实例</p>
<p><strong>但是需要指出的是ThreadLocal的性能是在有线程池的情况下，假如没有线程池，和每个线程单独new一个DateFormat实例是没有区别的</strong></p>
<p><img src="http://1.bp.blogspot.com/_tWwHCKnIbjs/TDndNvP6o4I/AAAAAAAAAAQ/lEUc81qwLqY/s1600/chart.png" alt="性能排序"></p>
<blockquote>
<p>所以我建议，多线程环境下，最好不用使用SimpleDateFormat，无论哪种方法都会写一些多余的代码，性能也不见得好。</p>
</blockquote>
<h3 id="线程安全的Date-Formatter"><a href="#线程安全的Date-Formatter" class="headerlink" title="线程安全的Date Formatter"></a>线程安全的Date Formatter</h3><p>在Java 8之前的Java版本，我们可以考虑使用线程安全的类</p>
<ul>
<li>apache commons中的<a href="https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/time/FastDateFormat.html" target="_blank" rel="noopener">FastDateFormat</a></li>
<li>joda-time中的<a href="http://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormat.html" target="_blank" rel="noopener">DateTimeFormat</a></li>
</ul>
<h3 id="Java-8中的DateTimeFormatter"><a href="#Java-8中的DateTimeFormatter" class="headerlink" title="Java 8中的DateTimeFormatter"></a>Java 8中的DateTimeFormatter</h3><p>Java 8中引入了新的包<code>java.time</code>，完美的解决了线程不安全的问题。</p>
<p>将字符串转换成<code>java.time.LocalDate</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//convert String to LocalDate</span></span><br><span class="line">LocalDate localDate = LocalDate.parse(<span class="string">"2016-01-01"</span>, formatter);</span><br><span class="line"></span><br><span class="line">System.out.println(localDate);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2017/11/30/blog-from-today/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/30/blog-from-today/" class="post-title-link" itemprop="url">从今天开始写博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-30 21:45:00" itemprop="dateCreated datePublished" datetime="2017-11-30T21:45:00+08:00">2017-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-12-01 13:33:08" itemprop="dateModified" datetime="2017-12-01T13:33:08+08:00">2017-12-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多年以前的我会写博客，会记录当下的心情，会和朋友们在博客上打趣互捧。后来，大家渐渐的不玩博客了，我有段时间还在坚持写，甚至会自己买域名维护网站，尽管没有什么人来看，那时候仅仅是默默的记录着自己的足迹，所思所想。<br>这么多年过去了，大家从博客转向了微博，又从微博转向了朋友圈，似乎所感所想变得越来越精炼，大家也没有兴趣没有耐性再去看什么长篇大论了。这个时代已经变成“快文化”为主导了。<br>其实，很多时候很多话都想写下来，但微博和朋友圈似乎并不是一个好的出口。首先朋友圈的“快文化”似乎并不能完整清晰的表达我们的想法，几张p过的食物照片，几张到此一游的相片，只能代表我吃了，我去了，我有钱，我有闲，有品位，大家来赞我吧，大家来羡慕我吧，这样的社交文化太肤浅。其次朋友圈对我而言太过“overwelming”，我本性不喜欢被太多人关注私生活，我讨厌过多的社交，似乎与知心的三五好友互通往来，知道对方发生了什么，在做着什么，这样的方式更适合我。我也不想被赞和评论束缚，这有悖于我想记录文字的初衷，别人看不看与我无关，别人喜不喜欢与我无关。我只是单纯的想给自己留下点足迹，至少多年以后翻开看，原来那个时候我是这样想的啊，原来那个时候我竟然做成了这件事啊。或许，从现在开始我不应该犯懒了。<br>这个博客，会有很多是关于程序员的世界，会有关于我和我的家庭，会有游记，会有影评，还会有书评。<br>话不多说，关键在于坚持。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Stephanie Tang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephanie Tang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
