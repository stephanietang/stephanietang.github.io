<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Stephanie Tang&#39;s Blog">
<meta property="og:url" content="http://stephanietang.github.io/index.html">
<meta property="og:site_name" content="Stephanie Tang&#39;s Blog">
<meta property="article:author" content="Stephanie Tang">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://stephanietang.github.io/"/>





  <title>Stephanie Tang's Blog</title>
  














<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Stephanie Tang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2020/04/13/Cache-Patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/13/Cache-Patterns/" itemprop="url">缓存模式以及缓存的数据一致性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T21:45:00+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>缓存由于其高性能，支持高并发以及高可用的特性，在高并发的项目中不可或缺。被大家广泛使用的有Redis，Memcached等。本文主要探讨几种常见的缓存的读写模式，以及如何来保证缓存和数据库的数据一致性。</p>
<h2 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache-Aside"></a>Cache-Aside</h2><p>Cache-Aside可能是系统中最常见的一种模式。它是一种控制逻辑都实现在应用程序中的模式。缓存不和数据库直接进行交互，而是由应用程序来同时和缓存以及数据库打交道。Cache-Aside的名字正体现了这个模式，Cache在应用的一旁(aside)。</p>
<p>读数据时</p>
<ol>
<li>程序需要判断缓存中是否已经存在数据。</li>
<li>当缓存中已经存在数据(也就是缓存命中，cache hit)，则直接从缓存中返回数据</li>
<li>当缓存中不存在数据(也就是缓存未命中，cache miss)，则先从数据库里读取数据，并且存入缓存，然后返回数据</li>
</ol>
<p><img src="https://i.niupic.com/images/2020/04/13/7oXo.PNG" alt="Cache Aside Read"></p>
<p>写数据时，我们可以有以下两种策略：</p>
<p>第一种策略：</p>
<ol>
<li>更新数据库</li>
<li>更新缓存</li>
</ol>
<p>但这种策略有线程安全的问题，可能出现缓存和数据库不一致。试想有两个写的线程，线程A和线程B</p>
<ol>
<li>A写数据库</li>
<li>B后于A写数据库</li>
<li>B写缓存</li>
<li>A写缓存</li>
<li>缓存和数据库中的数据不一致，缓存中的是脏数据</li>
</ol>
<p>要解决线程安全的问题，我们可以加锁，不过实现起来比较麻烦，因此我们不考虑这种写策略，而使用第二种策略。</p>
<p>第二种策略：</p>
<ol>
<li>更新数据库</li>
<li>删除缓存中对应的数据</li>
</ol>
<p><img src="https://i.niupic.com/images/2020/04/13/7oXC.PNG" alt="Cache Aside Write"></p>
<p>那么这种写策略会有线程安全的问题吗？有，试想一下有两个线程，线程A读，线程B写</p>
<ol>
<li>A读数据，由于未命中那么从数据库中取数据</li>
<li>B写数据库</li>
<li>B删除缓存</li>
<li>A由于网络延迟比较慢，将脏数据写入缓存</li>
</ol>
<p>但是这种情况可能性非常的小，需要同时满足很多条件，近乎不太可能发生，所以我们一般都采用这种写策略。另外可以对缓存中的数据设置合适的过期时间，即使发生的脏数据的情况，也不会发生很长时间。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>应用于缓存不支持Read-Through/Write-Through的系统。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>缓存仅仅保存被请求的数据，属于懒加载模式(Lazy Loading)，和下文的Write-Through模式相比，避免了任何数据都被写入缓存造成缓存频繁的更新。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>当发生缓存未命中的情况时，则会比较慢，因为要经过三个步骤：查询缓存，从数据库读取，写入缓存。</p>
</li>
<li><p>复杂的逻辑都在应用程序中，如果实现微服务，多个微服务中会有重复的逻辑代码</p>
</li>
</ul>
<h2 id="Read-Through-Write-Through"><a href="#Read-Through-Write-Through" class="headerlink" title="Read-Through/Write-Through"></a>Read-Through/Write-Through</h2><p>这种模式中，应用程序将缓存作为主要的数据源，而数据库对于应用程序是透明的，更新数据库和从数据库的读取的任务都交给缓存来代理了，所以对于应用程序来说，简单很多。</p>
<h3 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read-Through"></a>Read-Through</h3><p>由缓存配置一个读模块，它知道如何将数据库中的数据写入缓存。在数据被请求的时候，如果未命中，则将数据从数据库载入缓存。</p>
<p><img src="https://i.niupic.com/images/2020/04/13/7pf1.PNG" alt="Read Through"></p>
<h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write-Through"></a>Write-Through</h3><p>缓存配置一个写模块，它知道如何将数据写入数据库。当应用要写入数据时，缓存会先存储数据，并调用写模块将数据写入数据库。</p>
<p><img src="https://i.niupic.com/images/2020/04/13/7pfb.PNG" alt="Write Through"></p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>Read Through/Write Through适用于写入之后经常被读取的应用。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>缓存不存在脏数据</p>
</li>
<li><p>相比较Cache-Aside懒加载模式，读取速度更高，因为较少因为缓存未命中而从数据库中查找</p>
</li>
<li><p>应用程序的逻辑相对简单</p>
</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对于总是写入却很少被读取的应用，那么Write-Through会非常浪费性能，因为数据可能更改了很多次，却没有被读取，白白的每次都写入缓存造成写入延迟。</li>
</ul>
<p>除了Write-Through以外，我们还有另外的两种写模式可以和Read-Through一起来配合使用，分别是Write-Back和Write-Around。</p>
<h2 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write-Back"></a>Write-Back</h2><p>又叫做Write-Behind。和Write-Through写入的时机不同，Write-Back将缓存作为可靠的数据源，每次都只写入缓存，而写入数据库则采用异步的方式，比如当数据要被移除出缓存的时候再存储到数据库或者一段时间之后批量更新数据库。</p>
<p><img src="https://i.niupic.com/images/2020/04/13/7pg5.PNG" alt="Write Back"></p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>读写效率都非常好，写的时候因为异步存储到数据库，提升了写的效率，适用于读写密集的应用。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>写入和读取数据都非常的快，因为都是从缓存中直接读取和写入。</p>
</li>
<li><p>对于数据库不可用的情况有一定的容忍度，即使数据库暂时不可用，系统也整体可用，当数据库之后恢复的时候，再将数据写入数据库。</p>
</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>有数据丢失的风险，如果缓存挂掉而数据没有及时写到数据库中，那么缓存中的有些数据将永久的丢失了</li>
</ul>
<h2 id="Write-Around"><a href="#Write-Around" class="headerlink" title="Write-Around"></a>Write-Around</h2><p>和Write-Through不同，更新的时候只写入数据库，不写入缓存，结合Read-Through或者Cache-Aside使用，只在缓存未命中的情况下写缓存。</p>
<p><img src="https://i.niupic.com/images/2020/04/13/7pga.PNG" alt="Write Around"></p>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>适合于只写入一次而很少被读取的应用。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>相比较Write-Through写入的时候的效率较高，如果数据写入后很少被读取，缓存也不会被没用到的数据占满。</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>如果数据会写入多次，那么可能存在缓存和数据库不一致</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://shahriar.svbtle.com/Understanding-writethrough-writearound-and-writeback-caching-with-python" target="_blank" rel="noopener">https://shahriar.svbtle.com/Understanding-writethrough-writearound-and-writeback-caching-with-python</a></li>
<li><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9041659.html</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside</a></li>
<li><a href="https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/" target="_blank" rel="noopener">https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/</a></li>
<li><a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Strategies.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Strategies.html</a></li>
<li><a href="https://dzone.com/articles/using-read-through-amp-write-through-in-distribute" target="_blank" rel="noopener">https://dzone.com/articles/using-read-through-amp-write-through-in-distribute</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2018/03/01/Singleton-DesignPattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/Singleton-DesignPattern/" itemprop="url">单例设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-01T09:22:52+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单例设计模式(Singleton Design Pattern)指的是实现一个类，在应用中只有唯一一个实例。但现在已经成为业界共识，它成为了反模式的代表。这篇文章先讨论实现单例模式的几种方式，然后讨论为什么它是一种反模式。以及它的应用场景。</p>
<p>我们先来讨论单例模式的几种实现方法。</p>
<h3 id="饿汉式-Eager-Initialization）"><a href="#饿汉式-Eager-Initialization）" class="headerlink" title="饿汉式(Eager Initialization）"></a>饿汉式(Eager Initialization）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitializationSingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerInitializationSingleton instance = <span class="keyword">new</span> EagerInitializationSingleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//private constructor to avoid client applications to use constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerInitializationSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerInitializationSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种写法不算很复杂，因为声明了static和final，在类加载的时候就实例化了，另外将constructor声明为private，也就是不能使用new来创建实例，而只能使用<code>getInstance()</code>来得到唯一的实例，从而保证了只有一个实例。</p>
<p>但是这种方法的坏处显而易见，它在类加载的时候就初始化了，对于从来没有用过但是创建又需要很多资源的对象，这无疑是一种浪费。于是就有了懒汉式(lazy initialization)。</p>
<h3 id="双检锁-Double-Checked-Locking"><a href="#双检锁-Double-Checked-Locking" class="headerlink" title="双检锁(Double Checked Locking)"></a>双检锁(Double Checked Locking)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Double-checked Locking Lazy Initialization</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLockSingleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckedLockSingleton singleton;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckedLockSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(DoubleCheckedLockSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">					singleton = <span class="keyword">new</span> DoubleCheckedLockSingleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种双检锁是一种懒汉式——只有调用<code>getInstance()</code>的时候才实例化对象。但逻辑比饿汉式复杂许多，让我们来仔细看一看。<br><code>getInstance()</code>方法中使用了双检锁，这么做避免了同步整个getInstance()方法，因为只是在第一次实例化时需要同步，创建好之后，就可以直接返回已经创建好的singleton了。又是懒汉式，又不需要同步整个getInstance()方法影响性能，开销不算太大。<br>然而这里还有个坑，注意这里的<code>volatile</code>，尽管有了<code>synchronized</code>，但如果没有声明<code>volatile</code>，这个看似完美的方法还是会失效。<br>话说因为<code>singleton = new DoubleCheckedLockSingleton()</code>这个操作实际上含有三个步骤</p>
<p>(1) 给singleton对象分配内存<br>(2) 调用构造器来初始化成员变量<br>(3) 将singleton对象指向分配好的内存空间(执行这一步之后singleton != null)</p>
<p>然而JMM中指令是存在重排序的，也就是不能保证(2)和(3)的次序。<br>假设两个线程同时进入第一层<code>if(singleton == null)</code>，假设线程A首先进入了<code>synchronized block</code>，但是执行完<code>singleton = new DoubleCheckedLockSingleton()</code>之后，仅仅只完成了步骤(3)，singleton对象指向分配好的内存空间（并没有完成构造器的初始化工作），然后返回。线程B这时候进入<code>synchronized block</code>，看见singleton已经不等于null了，于是也返回了，然后使用这个没有真正初始化完成的实例，便会有不可预知的问题。<br>所以这里加上<code>volatile</code>之后禁止指令重排，根据happens-before原则，写操作将会先行发生于后面发生的读操作，也就是线程B一定读到的是线程A实例化完整的实例。<br>但是请注意，即使是使用了<code>volatile</code>，在Java 5之前仍旧是有问题的，Java 5之前的JMM<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">有bug</a>，并不能保证禁止重排序。<br>所以对于这么多坑的一种写法，我们明白了原理就算了，能避免就避免吧。</p>
<h3 id="静态内部类-Static-Inner-Class"><a href="#静态内部类-Static-Inner-Class" class="headerlink" title="静态内部类(Static Inner Class)"></a>静态内部类(Static Inner Class)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingleton INSTANCE = <span class="keyword">new</span> InnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法也是懒汉式的，同时读取实例的时候不会进行同步，没有性能缺陷，也不依赖JDK版本。完美！</p>
<h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法太简单了！有没有！它也是懒汉式的，天然的保证了线程安全，天然的不需要同步，不过当然需要Java 5以上的版本啦（Java 5之前也得有enum才行啊！），也是《Effective Java》上推荐的方法。</p>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>这里有一篇关于几种写法的性能比较：<a href="http://literatejava.com/jvm/fastest-threadsafe-singleton-jvm/" target="_blank" rel="noopener">Fastest Thread-safe Singleton in Java</a></p>
<p>但是没有出乎意料，对于懒汉式的写法中，静态内部类 &gt; 双检锁 &gt; synchronized getInstance方法（本文没有讨论，因为性能实在是堪忧）。这里没有比较enum，留给有兴趣的童鞋吧。</p>
<p>如果一定要实现一个单例设计模式，就我而言，我会采用enum的写法。</p>
<h2 id="为什么单例模式是一个反模式？"><a href="#为什么单例模式是一个反模式？" class="headerlink" title="为什么单例模式是一个反模式？"></a>为什么单例模式是一个反模式？</h2><p>那么讨论完单例模式的几种实现方法，我们再来说明为什么它已然已经成为业界共识的反模式了。纳尼？前面铺垫那么多，不是白讨论了吗？！虽然是浪费了很多口舌，但是单例模式依然有他的应用场景，我们后面会说。</p>
<p>首先我们要搞清楚两个概念：单例模式和单例。前者是一种设计模式，它的特征是：1)私有的构造器，2)通过<code>Singleton.getInstance()</code>方法获得该类的唯一实例。而单例指的是一个类有且只有一个实例，可以通过依赖注入来实现。Spring中，我们常用的service或者dao通常就是典型的单例，它们通过BeanFactory来进行依赖注入，来保证应用中引用的都是一个类的同一个实例。</p>
<p>要注意的是，Spring中默认的singleton scope和严格意义上单例还是有区别的，来自Spring的文档中指出：</p>
<blockquote>
<p>When a bean is a singleton, only one shared instance of the bean will be managed and all requests for beans with an id or ids matching that bean definition will result in that one specific bean instance being returned.</p>
</blockquote>
<p>也就是说你在Spring中定义了singleton的使用范围，并不能保证你的bean在应用中是绝对的唯一实例，因为这个bean通常有公有的构造器，你完全可以绕过Spring而<code>new</code>一个实例。</p>
<p>单例模式之所以是一个反模式，是因为：</p>
<ul>
<li>它通常是一个复杂的object，维护着一个全局的状态，而全局的状态使得结果不可预测</li>
<li>由于是私有构造器，单元测试变得困难</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>基本的原则就是<strong>不要自己实现单例模式</strong>，然而依然有场景（为数不多的）适合使用单例模式，譬如logging：</p>
<ul>
<li>客户代码需要一个全局的logging service来发送请求去写log</li>
<li>多个监听器(listener)可以注册同一个logging service</li>
<li>虽然不同的应用会有不同的输出，它们注册监听器的方法是一样的，它们可以定制监听器来实现不同的配置，客户代码不需要知道log在哪里或如何写log的</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确地写出单例模式</a></li>
<li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">The “Double-Checked Locking is Broken” Declaration</a></li>
<li><a href="http://literatejava.com/jvm/fastest-threadsafe-singleton-jvm/" target="_blank" rel="noopener">Fastest Thread-safe Singleton in Java</a></li>
<li><a href="http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/" target="_blank" rel="noopener">Singletons are Pathological Liars</a></li>
<li><a href="http://misko.hevery.com/2008/08/21/where-have-all-the-singletons-gone/" target="_blank" rel="noopener">Where Have All the Singletons Gone?</a></li>
<li><a href="http://misko.hevery.com/2008/08/25/root-cause-of-singletons/" target="_blank" rel="noopener">Root Cause of Singletons</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2017/12/02/ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/02/ThreadLocal/" itemprop="url">深入理解Java中的ThreadLocal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-02T09:22:52+08:00">
                2017-12-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h2><ol>
<li><p>每个<code>Thread</code>中都维护有一个<code>ThreadLocalMap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个<code>ThreadLocalMap</code>的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>就是每个线程要独立使用的Object。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">...    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个<code>Thread</code>要获得Object的时候，首先会调用<code>getMap(Thread t)</code>找到当前线程的<code>ThreadLocalMap</code>，然后使用<code>ThreadLocal</code>实例作为<code>key</code>，找到对应的<code>value</code>，也就是要找的Object。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这样每个线程都有独立使用的Object，就不会有线程之间相互干扰的问题，也不需要同步，因为不存在线程共享。</p>
</li>
</ol>
<h2 id="ThreadLocal的内存泄漏问题"><a href="#ThreadLocal的内存泄漏问题" class="headerlink" title="ThreadLocal的内存泄漏问题"></a>ThreadLocal的内存泄漏问题</h2><p>从源代码中，我们可以知道<code>ThreadLocalMap.Enty</code>对key（也就是<code>ThreadLocal</code>实例）是<code>WeakReference</code>，那么GC会将ThreadLocal回收，然而Entry的value不会被回收。但是如果线程及时结束，因为<code>ThreadLocalMap</code>和<code>Thread</code>的生命周期是一样的，所以ThreadLocalMap也会被回收，也就不会有内存泄漏的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题就出在假如使用了线程池，线程池中的线程完成任务后还会继续放回线程池而不会结束，这样就造成了泄漏：value中的Object虽然不会再被访问到(因为作为key的ThreadLocal已经被回收了)，但是由于ThreadLocalMap.Entry对value还存在强引用，所以value不会被回收，而Thread又一直存活，这样value就永远无法被回收了。</p>
<h2 id="解决ThreadLocal内存泄漏的最佳实践"><a href="#解决ThreadLocal内存泄漏的最佳实践" class="headerlink" title="解决ThreadLocal内存泄漏的最佳实践"></a>解决ThreadLocal内存泄漏的最佳实践</h2><p>解决方案一：不在有线程池的web应用中使用ThreadLocal</p>
<p>解决方案二：如果一定要在有线程池的web应用中使用ThreadLocal，那么在线程执行完任务之前，要调用<code>ThreadLocal.remove()</code>来清除value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(value);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a></li>
<li><a href="http://niklasschlimm.blogspot.hk/2012/04/threading-stories-threadlocal-in-web.html" target="_blank" rel="noopener">Threading stories: ThreadLocal in web applications</a></li>
<li><a href="https://github.com/dropwizard/metrics/issues/742" target="_blank" rel="noopener">https://github.com/dropwizard/metrics/issues/742</a></li>
<li><a href="https://wiki.apache.org/tomcat/MemoryLeakProtection" target="_blank" rel="noopener">https://wiki.apache.org/tomcat/MemoryLeakProtection</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2017/12/01/Why-SimpleDateFormat-Is-Not-Thread-Safe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/01/Why-SimpleDateFormat-Is-Not-Thread-Safe/" itemprop="url">为什么SimpleDateFormat不是线程安全的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-01T11:12:05+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么SimpleDateFormat不是线程安全的"><a href="#为什么SimpleDateFormat不是线程安全的" class="headerlink" title="为什么SimpleDateFormat不是线程安全的"></a>为什么SimpleDateFormat不是线程安全的</h2><p>我们用一个简单的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatNotThreadSafe</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateFormat FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> MyThread(String.valueOf(i));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        MyThread(String threadName) &#123;</span><br><span class="line">            <span class="keyword">super</span>(threadName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Created Thread "</span> + getName() + <span class="string">", "</span>+ FORMAT.parse(<span class="string">"2016-01-01"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span>( Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于是多线程程序，线程运行的先后不可预知。但是奇怪的事情发生了，连可预知的<code>FORMAT.parse(&quot;2016-01-01&quot;)</code>也出现了奇怪的结果。</p>
<p>以下是几个可能出现的错误结果：</p>
<p>错误结果1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Created Thread 2, Wed Jan 01 00:00:00 HKT 2200</span><br><span class="line">Created Thread 6, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 7, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 8, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 4, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 3, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 9, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 0, Wed Jan 01 00:00:00 HKT 2200</span><br><span class="line">Created Thread 1, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 5, Fri Jan 01 00:00:00 HKT 2016</span><br></pre></td></tr></table></figure>

<p>错误结果2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Created Thread 1, Sat May 26 09:34:08 HKT 164390675</span><br><span class="line">Created Thread 3, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 4, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 0, Fri Jan 01 00:00:00 HKT 42016</span><br><span class="line">Created Thread 5, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 6, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 2, Fri Jan 01 00:00:00 HKT 42016</span><br><span class="line">Created Thread 7, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1110)</span><br><span class="line">    at java.lang.Double.parseDouble(Double.java:540)</span><br><span class="line">    at java.text.DigitList.getDouble(DigitList.java:168)</span><br><span class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1321)</span><br><span class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2088)</span><br><span class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)</span><br><span class="line">    at java.text.DateFormat.parse(DateFormat.java:355)</span><br><span class="line">    at com.examples.tutorials.SimpleDateFormatNotThreadSafe$MyThread.run(SimpleDateFormatNotThreadSafe.java:27)</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1110)</span><br><span class="line">    at java.lang.Double.parseDouble(Double.java:540)</span><br><span class="line">    at java.text.DigitList.getDouble(DigitList.java:168)</span><br><span class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1321)</span><br><span class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)</span><br><span class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)</span><br><span class="line">    at java.text.DateFormat.parse(DateFormat.java:355)</span><br><span class="line">    at com.examples.tutorials.SimpleDateFormatNotThreadSafe$MyThread.run(SimpleDateFormatNotThreadSafe.java:27)</span><br></pre></td></tr></table></figure>

<p>错误结果3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: For input string: &quot;.11E.111E&quot;</span><br><span class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1250)</span><br><span class="line">    at java.lang.Double.parseDouble(Double.java:540)</span><br><span class="line">    at java.text.DigitList.getDouble(DigitList.java:168)</span><br><span class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1321)</span><br><span class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)</span><br><span class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)</span><br><span class="line">    at java.text.DateFormat.parse(DateFormat.java:355)</span><br><span class="line">    at com.examples.tutorials.SimpleDateFormatNotThreadSafe$MyThread.run(SimpleDateFormatNotThreadSafe.java:27)</span><br><span class="line">java.lang.NumberFormatException: For input string: &quot;.11E.111E1&quot;</span><br><span class="line">    at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1250)</span><br><span class="line">    at java.lang.Double.parseDouble(Double.java:540)</span><br><span class="line">    at java.text.DigitList.getDouble(DigitList.java:168)</span><br><span class="line">    at java.text.DecimalFormat.parse(DecimalFormat.java:1321)</span><br><span class="line">    at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)</span><br><span class="line">    at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)</span><br><span class="line">    at java.text.DateFormat.parse(DateFormat.java:355)</span><br><span class="line">    at com.examples.tutorials.SimpleDateFormatNotThreadSafe$MyThread.run(SimpleDateFormatNotThreadSafe.java:27)</span><br><span class="line">Created Thread 1, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 6, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 3, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 5, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 4, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 7, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 8, Fri Jan 01 00:00:00 HKT 2016</span><br><span class="line">Created Thread 9, Fri Jan 01 00:00:00 HKT 2016</span><br></pre></td></tr></table></figure>

<p>这正是因为SimpleDateFormat是非线程安全所导致的，这应该是设计者的错误。但是基于向后兼容，JDK中一直没有将它改为线程安全。然后Java 8引入了新的类解决了这一问题，下面会进行详细阐述。<br>从SimpleteDateFormat的<a href="http://developer.classpath.org/doc/java/text/SimpleDateFormat-source.html" target="_blank" rel="noopener">源代码</a>中可以知道，<code>parse(..)</code>的时候，首先会<code>calender.clear()</code>，然后会<code>calender.set(..)</code>。如果一个线程<code>parse(..)</code>还没有返回，另一个线程也进入了<code>parse(..)</code>并进行了<code>calender.clear()</code>，那么第一个线程将会得到意想不到的结果。</p>
<p>所以在SimpleDateFormat的文档中，也做了说明：</p>
<blockquote>
<p>Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p>
</blockquote>
<h2 id="如何写出线程安全的date-formatter"><a href="#如何写出线程安全的date-formatter" class="headerlink" title="如何写出线程安全的date formatter"></a>如何写出线程安全的date formatter</h2><p>针对写出线程安全的date formatter，在Java 8之前主要有三种方法:</p>
<ul>
<li>每个线程使用单独的DateFormat实例</li>
<li>使用synchronized进行同步</li>
<li>使用ThreadLocal</li>
</ul>
<h3 id="每个线程使用单独的DateFormat实例"><a href="#每个线程使用单独的DateFormat实例" class="headerlink" title="每个线程使用单独的DateFormat实例"></a>每个线程使用单独的DateFormat实例</h3><p>在每个线程里，创建一个新的DateFormat实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatThreadSafe</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convertStringToDate</span><span class="params">(String dateString)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        <span class="keyword">return</span> df.parse(dateString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法虽然实现起来很简单，但是效率非常的低。</p>
<h3 id="使用synchronized进行同步"><a href="#使用synchronized进行同步" class="headerlink" title="使用synchronized进行同步"></a>使用synchronized进行同步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatThreadSafeSynchronized</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateFormat FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convertStringToDate</span><span class="params">(String dateString)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        Date result;</span><br><span class="line">        <span class="keyword">synchronized</span>(FORMAT) &#123;</span><br><span class="line">            result = FORMAT.parse(dateString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalThreadSafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; FORMAT = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convertStringToDate</span><span class="params">(String dateString)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FORMAT.get().parse(dateString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以上三种方法的性能测试"><a href="#以上三种方法的性能测试" class="headerlink" title="以上三种方法的性能测试"></a>以上三种方法的性能测试</h3><p><a href="https://www.javacodegeeks.com/2010/07/java-best-practices-dateformat-in.html" target="_blank" rel="noopener">有人</a>针对以上的三种方法进行了性能测试，性能排序为：</p>
<p>使用ThreadLocal &gt; 使用synchronized进行同步 &gt; 每个线程使用单独的DateFormat实例</p>
<p><strong>但是需要指出的是ThreadLocal的性能是在有线程池的情况下，假如没有线程池，和每个线程单独new一个DateFormat实例是没有区别的</strong></p>
<p><img src="http://1.bp.blogspot.com/_tWwHCKnIbjs/TDndNvP6o4I/AAAAAAAAAAQ/lEUc81qwLqY/s1600/chart.png" alt="性能排序"></p>
<blockquote>
<p>所以我建议，多线程环境下，最好不用使用SimpleDateFormat，无论哪种方法都会写一些多余的代码，性能也不见得好。</p>
</blockquote>
<h3 id="线程安全的Date-Formatter"><a href="#线程安全的Date-Formatter" class="headerlink" title="线程安全的Date Formatter"></a>线程安全的Date Formatter</h3><p>在Java 8之前的Java版本，我们可以考虑使用线程安全的类</p>
<ul>
<li>apache commons中的<a href="https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/time/FastDateFormat.html" target="_blank" rel="noopener">FastDateFormat</a></li>
<li>joda-time中的<a href="http://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormat.html" target="_blank" rel="noopener">DateTimeFormat</a></li>
</ul>
<h3 id="Java-8中的DateTimeFormatter"><a href="#Java-8中的DateTimeFormatter" class="headerlink" title="Java 8中的DateTimeFormatter"></a>Java 8中的DateTimeFormatter</h3><p>Java 8中引入了新的包<code>java.time</code>，完美的解决了线程不安全的问题。</p>
<p>将字符串转换成<code>java.time.LocalDate</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//convert String to LocalDate</span></span><br><span class="line">LocalDate localDate = LocalDate.parse(<span class="string">"2016-01-01"</span>, formatter);</span><br><span class="line"></span><br><span class="line">System.out.println(localDate);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stephanietang.github.io/2017/11/30/Blog-From-Today/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stephanie Tang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stephanie Tang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/Blog-From-Today/" itemprop="url">从今天开始写博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T21:45:00+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>多年以前的我会写博客，会记录当下的心情，会和朋友们在博客上打趣互捧。后来，大家渐渐的不玩博客了，我有段时间还在坚持写，甚至会自己买域名维护网站，尽管没有什么人来看，那时候仅仅是默默的记录着自己的足迹，所思所想。<br>这么多年过去了，大家从博客转向了微博，又从微博转向了朋友圈，似乎所感所想变得越来越精炼，大家也没有兴趣没有耐性再去看什么长篇大论了。这个时代已经变成“快文化”为主导了。<br>其实，很多时候很多话都想写下来，但微博和朋友圈似乎并不是一个好的出口。首先朋友圈的“快文化”似乎并不能完整清晰的表达我们的想法，几张p过的食物照片，几张到此一游的相片，只能代表我吃了，我去了，我有钱，我有闲，有品位，大家来赞我吧，大家来羡慕我吧，这样的社交文化太肤浅。其次朋友圈对我而言太过“overwelming”，我本性不喜欢被太多人关注私生活，我讨厌过多的社交，似乎与知心的三五好友互通往来，知道对方发生了什么，在做着什么，这样的方式更适合我。我也不想被赞和评论束缚，这有悖于我想记录文字的初衷，别人看不看与我无关，别人喜不喜欢与我无关。我只是单纯的想给自己留下点足迹，至少多年以后翻开看，原来那个时候我是这样想的啊，原来那个时候我竟然做成了这件事啊。或许，从现在开始我不应该犯懒了。<br>这个博客，会有很多是关于程序员的世界，会有关于我和我的家庭，会有游记，会有影评，还会有书评。<br>话不多说，关键在于坚持。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Stephanie Tang" />
          <p class="site-author-name" itemprop="name">Stephanie Tang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephanie Tang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
